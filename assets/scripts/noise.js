let o=!1,n=!1;const i={background:{path:"assets/audio/background.wav",loop:!0,defaultVolume:.1},rumble:{path:"assets/audio/rumble.mp3",loop:!1,defaultVolume:1}},t={number:28,range:[1,10]},u=new window.AudioContext,r={},c={};function e(e,t=0){var a;i[e]&&!n&&((a=u.createBufferSource()).buffer=c[e],a.loop=i[e].loop,a.connect(r[e]),o||(r[e].gain.setValueAtTime(0,u.currentTime),r[e].gain.linearRampToValueAtTime(i[e].defaultVolume,u.currentTime+t)),a.start(),e.includes("voiceLine")&&(n=!0),e.includes("voiceLine"))&&(a.onended=()=>{n=!1})}function a(){o=!0,Object.values(r).forEach(e=>{e.gain.linearRampToValueAtTime(0,u.currentTime+.5)})}function l(){o=!1,Object.entries(r).forEach(([e,t])=>{t.gain.linearRampToValueAtTime(i[e].defaultVolume,u.currentTime+.5)})}function m(){e("voiceLine"+(Math.floor(Math.random()*t.number)+1),.3)}for(let e=1;e<=t.number;e+=1)i["voiceLine"+e]={path:`assets/audio/zoltar-voice-lines/zoltar-voice-${e}.mp3`,loop:!1,defaultVolume:1};Object.entries(i).forEach(([t,e])=>{r[t]=u.createGain(),r[t].gain.setValueAtTime(0,u.currentTime),r[t].connect(u.destination),fetch(e.path).then(e=>e.arrayBuffer()).then(e=>u.decodeAudioData(e)).then(e=>{c[t]=e})});export{e as playAudio,a as mute,l as unmute,m as playRandomVoiceLine};